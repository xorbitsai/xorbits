# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2022-2023, Xprobe Inc.
# This file is distributed under the same license as the Xorbits package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2023.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Xorbits \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2023-02-03 14:44+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.11.0\n"

#: ../../source/development/contributing_codebase.rst:5
msgid "Contributing to the code base"
msgstr "为代码库做出贡献"

#: ../../source/development/contributing_codebase.rst:8
msgid "Table of Contents:"
msgstr "目录："

#: ../../source/development/contributing_codebase.rst:11
msgid "Code standards"
msgstr "代码规范"

#: ../../source/development/contributing_codebase.rst:13
msgid ""
"Writing good code is not just about what you write. It is also about "
"*how* you write it. During :ref:`Continuous Integration "
"<contributing.ci>` testing, several tools will be run to check your code "
"for stylistic errors. Good style is a requirement for submitting code to "
"Xorbits."
msgstr ""
"写好代码不仅仅是关于你写的内容，也与你如何写有关。"
"在 :ref:`Continuous Integration <contributing.ci>` 测试期间，我们将运行几个工具来检查你的代码样式错误。"
"好的代码风格是提交代码给Xorbits的要求。"

#: ../../source/development/contributing_codebase.rst:18
msgid ""
"In addition, it is important that we do not make sudden changes to the "
"code that could have the potential to break a lot of user code as a "
"result, that is, we need it to be as *backwards compatible* as possible "
"to avoid mass breakages."
msgstr ""
"此外，重要的是，我们不要对代码进行突然更改"
"这可能会导致大量用户代码中断"
"也就是说,我们需要它尽可能向后兼容，以避免大规模中断。"

#: ../../source/development/contributing_codebase.rst:23
msgid ""
"Checks (including static type checking) are run by ``pre-commit`` - see "
":ref:`here <contributing.pre-commit>` for how to run them."
msgstr ""
"检查（包括静态类型检查）由 ``pre-commit`` 运行-在 :ref:`这里 <contributing.pre-commit>` "
"见如何运行。"

#: ../../source/development/contributing_codebase.rst:30
msgid "Pre-commit"
msgstr "预提交"

#: ../../source/development/contributing_codebase.rst:32
msgid ""
"Additionally, :ref:`Continuous Integration <contributing.ci>` will run "
"code formatting checks like ``black``, ``flake8``, ``isort``, and more "
"using `pre-commit hooks <https://pre-commit.com/>`_ Any warnings from "
"these checks will cause the :ref:`Continuous Integration "
"<contributing.ci>` to fail; therefore, it is helpful to run the check "
"yourself before submitting code. This can be done by installing ``pre-"
"commit``::"
msgstr ""
"另外， :ref:`Continuous Integration <contributing.ci>` 将使用 `pre-commit hooks "
"<https://pre-commit.com/>`_ 运行代码格式检查，例如 ``black``, ``flake8``, ``isort`` 等等 "
"这些检查中的任何警告都将导致 :ref:`Continuous Integration <contributing.ci>` 失败。"
"因此，在提交代码之前自己运行检查很有帮助。可以通过安装 ``pre-commit`` 来完成： "

#: ../../source/development/contributing_codebase.rst:40
msgid "and then running::"
msgstr "然后运行："

#: ../../source/development/contributing_codebase.rst:44
msgid ""
"from the root of the Xorbits repository. Now all of the styling checks "
"will be run each time you commit changes without your needing to run each"
" one manually. In addition, using ``pre-commit`` will also allow you to "
"more easily remain up-to-date with our code checks as they change."
msgstr ""
"从Xorbits存储库的根目录运行此命令。"
"这样，每次提交更改时都会自动运行所有样式检查，无需手动运行每个检查。"
"此外，使用 ``pre-commit`` 还可以更轻松地保持与我们的代码检查的最新状态。"

#: ../../source/development/contributing_codebase.rst:49
msgid ""
"Note that if needed, you can skip these checks with ``git commit --no-"
"verify``."
msgstr ""
"请注意，如果需要"
"可以使用 ``git commit --no-verify`` 跳过这些检查。"

#: ../../source/development/contributing_codebase.rst:51
msgid ""
"If you don't want to use ``pre-commit`` as part of your workflow, you can"
" still use it to run its checks with::"
msgstr ""
"如果你不想将 ``pre-commit`` 作为工作流程的一部分使用，你"
"仍然可以使用以下命令运行检查："

#: ../../source/development/contributing_codebase.rst:56
#: ../../source/development/contributing_codebase.rst:62
msgid "without needing to have done ``pre-commit install`` beforehand."
msgstr "无需事先执行 ``pre-commit install`` 命令。"

#: ../../source/development/contributing_codebase.rst:58
msgid ""
"If you want to run checks on all recently committed files on "
"upstream/main you can use::"
msgstr ""
"如果要在upstream/main上运行所有最近提交的文件的检查"
"可以使用以下命令："

#: ../../source/development/contributing_codebase.rst:66
msgid ""
"You may want to periodically run ``pre-commit gc``, to clean up repos "
"which are no longer used."
msgstr ""
"你可能希望定期运行 ``pre-commit gc`` 命令，以清理"
"不再使用的仓库。"

#: ../../source/development/contributing_codebase.rst:71
msgid ""
"If you have conflicting installations of ``virtualenv``, then you may get"
" an error - see `here <https://github.com/pypa/virtualenv/issues/1875>`_."
msgstr ""
"如果你安装了冲突的版本 ``virtualenv``，可能会出现"
"错误 - 可以查看 `这里 <https://github.com/pypa/virtualenv/issues/1875>`_ 的解决方案。"

#: ../../source/development/contributing_codebase.rst:74
msgid ""
"Also, due to a `bug in virtualenv "
"<https://github.com/pypa/virtualenv/issues/1986>`_, you may run into "
"issues if you're using conda. To solve this, you can downgrade "
"``virtualenv`` to version ``20.0.33``."
msgstr ""
"此外，由于 `virtualenv存在bug <https://github.com/pypa/virtualenv/issues/1986>`_ "
"如果你使用conda，可能会遇到问题。"
"要解决此问题，你可以将 ``virtualenv`` 降级到版本 ``20.0.33`` 。"

#: ../../source/development/contributing_codebase.rst:79
msgid "Optional dependencies"
msgstr "可选依赖项"

#: ../../source/development/contributing_codebase.rst:81
msgid ""
"All methods using an optional dependency should include a test asserting "
"that an ``ImportError`` is raised when the optional dependency is not "
"found. This test should be skipped if the library is present."
msgstr ""
"所有使用可选依赖关系的方法都应包含一个断言测试，"
"如果未找到可选依赖关系则应引发 ``ImportError`` 错误。"
"如果已安装该库，则应跳过此测试。"

#: ../../source/development/contributing_codebase.rst:85
msgid ""
"All optional dependencies and the minimum required version should be "
"documented in :ref:`install.optional_dependencies`."
msgstr ""
"所有可选依赖项及其最低所需版本"
"应在 :ref:`install.optional_dependencies` 中进行记录和说明。"

#: ../../source/development/contributing_codebase.rst:89
msgid "Backwards compatibility"
msgstr "向后兼容性"

#: ../../source/development/contributing_codebase.rst:91
msgid ""
"Please try to maintain backward compatibility. If you think breakage is "
"required, clearly state why as part of the pull request.  Also, be "
"careful when changing method signatures and add deprecation warnings "
"where needed. Also, add the deprecated sphinx directive to the deprecated"
" functions or methods."
msgstr ""
"请尽可能保持向后兼容性。如果你认为需要进行破坏性更改，"
"请在拉取请求的一部分中清楚地说明原因。"
"在更改方法签名时，请注意添加必要的过时警告。"
"此外，请在过时的函数或方法中添加过时的sphinx指令。"

#: ../../source/development/contributing_codebase.rst:96
msgid "You'll also need to"
msgstr "你还需要"

#: ../../source/development/contributing_codebase.rst:98
msgid ""
"Write a new test that asserts a warning is issued when calling with the "
"deprecated argument"
msgstr ""
"编写一个新测试，确保在使用过时参数进行调用时发出警告"

#: ../../source/development/contributing_codebase.rst:99
msgid "Update all of Xorbits existing tests and code to use the new argument"
msgstr "更新Xorbit现有的所有测试和代码，使用新参数"

#: ../../source/development/contributing_codebase.rst:104
msgid "Type hints"
msgstr "类型提示"

#: ../../source/development/contributing_codebase.rst:106
msgid ""
"Xorbits strongly encourages the use of :pep:`484` style type hints. New "
"development should contain type hints and pull requests to annotate "
"existing code are accepted as well!"
msgstr ""
"Xorbits非常鼓励使用:pep:`484` 格式的类型提示。新的"
"开发应该包含类型提示，同时我们也接受请求来为现有代码添加注释！"

#: ../../source/development/contributing_codebase.rst:109
msgid "Style guidelines"
msgstr "风格指南"

#: ../../source/development/contributing_codebase.rst:111
msgid ""
"Type imports should follow the ``from typing import ...`` convention. "
"Some types do not need to be imported since :pep:`585` some builtin "
"constructs, such as ``list`` and ``tuple``, can directly be used for type"
" annotations. So rather than"
msgstr ""
"类型导入应遵循 ``from typing import ...`` 的约定。"
"某些类型无需导入，因为 :pep:`585` 中的一些内置"
"结构，如 ``list`` 和 ``tuple``，可以直接用于类型"
"注释。因此，而不是"

#: ../../source/development/contributing_codebase.rst:119
#: ../../source/development/contributing_codebase.rst:141
msgid "You should write"
msgstr "你应该写"

#: ../../source/development/contributing_codebase.rst:125
msgid ""
"``Optional`` should be  avoided in favor of the shorter ``| None``, so "
"instead of"
msgstr ""
"应该避免使用 ``Optional`` 而更喜欢较短的 ``| None``，所以"
"而不是"

#: ../../source/development/contributing_codebase.rst:133
msgid "or"
msgstr "或者"

#: ../../source/development/contributing_codebase.rst:149
msgid ""
"In some cases in the code base classes may define class variables that "
"shadow builtins. This causes an issue as described in `Mypy 1775 "
"<https://github.com/python/mypy/issues/1775#issuecomment-310969854>`_. "
"The defensive solution here is to create an unambiguous alias of the "
"builtin and use that without your annotation. For example, if you come "
"across a definition like"
msgstr ""
"在代码库中的某些情况下，类可能会定义类变量来屏蔽内置"
"变量。这会导致一些问题，如 `Mypy 1775 <https://github.com/python/mypy/issues/1775#issuecomment-310969854>`_ 所描述的那样。"
"在这种情况下，防御性的解决方案是创建一个不含歧义的别名，"
"并在编写类型注释时使用该别名。例如，如果你遇到以下类定义："

#: ../../source/development/contributing_codebase.rst:156
msgid "The appropriate way to annotate this would be as follows"
msgstr "在进行类型注释时，应该这样写："

#: ../../source/development/contributing_codebase.rst:167
msgid "Validating type hints"
msgstr "验证类型提示"

#: ../../source/development/contributing_codebase.rst:169
msgid ""
"Xorbits uses `mypy <http://mypy-lang.org>`_ and `pyright "
"<https://github.com/microsoft/pyright>`_ to statically analyze the code "
"base and type hints. After making any change you can ensure your type "
"hints are correct by running"
msgstr ""
"Xorbits使用 `mypy <http://mypy-lang.org>`_ 和"
" `pyright <https://github.com/microsoft/pyright>`_ 来静态分析代码"
"库和类型提示。在进行任何更改后，你可以通过运行以下命令确保你的类型提示是正确的："

#: ../../source/development/contributing_codebase.rst:179
msgid ""
"in your activated python environment. A recent version of ``numpy`` "
"(>=1.22.0) is required for type validation."
msgstr ""
"在你的虚拟环境中运行该命令。进行类型验证需要安装最新版本的 ``numpy`` (>=1.22.0)。"

#: ../../source/development/contributing_codebase.rst:184
msgid "Testing with continuous integration"
msgstr "使用持续集成进行测试"

#: ../../source/development/contributing_codebase.rst:186
msgid ""
"The Xorbits test suite will run automatically on `GitHub Actions "
"<https://github.com/features/actions/>`__ continuous integration "
"services, once your pull request is submitted. However, if you wish to "
"run the test suite on a branch prior to submitting the pull request, then"
" the continuous integration services need to be hooked to your GitHub "
"repository. Instructions are here for `GitHub Actions "
"<https://docs.github.com/en/actions/>`__."
msgstr ""
"Xorbits的测试套件将在你提交拉取请求后自动运行"
" `GitHub Actions <https://github.com/features/actions/>`__ 持续集成"
"服务。如果你希望在提交拉取请求之前在分支上运行测试套件，"
"则需要将持续集成服务与你的 GitHub 仓库钩子连接起来。"
"这里有 `GitHub Actions <https://docs.github.com/en/actions/>`__ 的说明。"

#: ../../source/development/contributing_codebase.rst:192
msgid ""
"A pull-request will be considered for merging when you have an all "
"'green' build. If any tests are failing, then you will get a red 'X', "
"where you can click through to see the individual failed tests. This is "
"an example of a green build."
msgstr ""
"当你的构建全部是"
" '绿色' 时，拉取请求将被考虑合并。如果任何测试失败，则会出现红色的 ‘X’，"
"你可以单击它以查看各个测试失败的详细信息。这是"
"一个成功构建的示例。"

#: ../../source/development/contributing_codebase.rst:202
msgid "Test-driven development"
msgstr "测试驱动开发"

#: ../../source/development/contributing_codebase.rst:204
msgid ""
"Xorbits is serious about testing and strongly encourages contributors to "
"embrace `test-driven development (TDD) <https://en.wikipedia.org/wiki"
"/Test-driven_development>`_. This development process \"relies on the "
"repetition of a very short development cycle: first the developer writes "
"an (initially failing) automated test case that defines a desired "
"improvement or new function, then produces the minimum amount of code to "
"pass that test.\" So, before actually writing any code, you should write "
"your tests.  Often the test can be taken from the original GitHub issue."
"  However, it is always worth considering additional use cases and "
"writing corresponding tests."
msgstr ""
"Xorbits非常注重测试，强烈鼓励"
"贡献者采用 `测试驱动开发 (TDD) <https://en.wikipedia.org/wiki"
"/Test-driven_development>`_。这种开发过程依赖于"
"非常短的开发循环：开发人员首先编写"
"一个（最初失败的）自动化测试用例，定义"
"所需的改进或新功能，然后生成最少量的代码以通过该测试。” 因此，在实际编写任何代码之前，应编写"
"测试。通常测试可以从原始的 GitHub 问题中获取。"
"但是，值得考虑其他用例并"
"编写相应的测试。"

#: ../../source/development/contributing_codebase.rst:213
msgid ""
"Adding tests is one of the most common requests after code is pushed to "
"Xorbits.  Therefore, it is worth getting in the habit of writing tests "
"ahead of time so this is never an issue."
msgstr ""
"在代码被推送到"
"Xorbits后，最常见的请求之一是添加测试。"
"因此，值得养成提前编写测试的习惯，以免出现这种情况。"

#: ../../source/development/contributing_codebase.rst:217
msgid "Writing tests"
msgstr "编写测试"

#: ../../source/development/contributing_codebase.rst:219
msgid ""
"All tests should go into the ``tests`` subdirectory of the specific "
"package. This folder contains many current examples of tests, and we "
"suggest looking to these for inspiration."
msgstr ""
"所有测试应该放在特定包的 ``tests`` 子目录中。"
"此文件夹包含许多当前的测试示例，我们"
"建议参考这些示例以获取灵感。"

#: ../../source/development/contributing_codebase.rst:223
msgid ""
"As a general tip, you can use the search functionality in your integrated"
" development environment (IDE) or the git grep command in a terminal to "
"find test files in which the method is called. If you are unsure of the "
"best location to put your test, take your best guess, but note that "
"reviewers may request that you move the test to a different location."
msgstr ""
"一般而言，可以使用集成开发环境 (IDE) 中的搜索功能或在终端中使用 git grep 命令来查找调用该方法的测试文件。"
"如果你不确定最佳位置来放置你的测试，请尽力猜测，"
"但请注意，审阅人可能会要求你将测试移动到其他位置。"

#: ../../source/development/contributing_codebase.rst:228
msgid "To use git grep, you can run the following command in a terminal:"
msgstr "要使用 git grep，你可以在终端中运行以下命令:"

#: ../../source/development/contributing_codebase.rst:230
msgid "``git grep \"function_name(\"``"
msgstr "``git grep \"function_name(\"``"

#: ../../source/development/contributing_codebase.rst:232
msgid ""
"This will search through all files in your repository for the text "
"``function_name(``. This can be a useful way to quickly locate the "
"function in the codebase and determine the best location to add a test "
"for it."
msgstr ""
"这将在你的代码库中的所有文件中搜索文本"
" ``function_name(`` 。这是一个快速定位"
"代码库中函数并确定最佳位置添加测试的有用方式。"

#: ../../source/development/contributing_codebase.rst:236
msgid ""
"Ideally, there should be one, and only one, obvious place for a test to "
"reside. Until we reach that ideal, these are some rules of thumb for "
"where a test should be located."
msgstr ""
"理想情况下，一个测试应该有一个且只有一个明显的位置。"
"在我们达到这个理想状态之前，这里有一些关于测试放置位置的经验法则。"

#: ../../source/development/contributing_codebase.rst:241
msgid "Using ``pytest``"
msgstr "使用 ``pytest``"

#: ../../source/development/contributing_codebase.rst:244
msgid "Test structure"
msgstr "测试结构"

#: ../../source/development/contributing_codebase.rst:246
msgid ""
"We prefer a more *functional* style using the `pytest "
"<https://docs.pytest.org/en/latest/>`__ framework, which offers a richer "
"testing framework that will facilitate testing and developing. Thus, "
"instead of writing test classes, we will write test functions like this:"
msgstr ""
"我们更喜欢使用 `pytest <https://docs.pytest.org/en/latest/>`__ 框架，"
"它提供了更丰富的测试框架，将有助于测试和开发，采用更 *functional* 式的风格。因此，"
"我们将编写测试函数，而不是编写测试类，例如下面的代码："

#: ../../source/development/contributing_codebase.rst:255
msgid "Preferred ``pytest`` idioms"
msgstr "首选的 ``pytest`` 编码风格"

#: ../../source/development/contributing_codebase.rst:257
msgid ""
"Functional tests named ``def test_*`` and *only* take arguments that are "
"either fixtures or parameters."
msgstr ""
"测试函数使用 ``def test_*`` 命名，只接受"
"fixture 或 parameter 参数作为输入。"

#: ../../source/development/contributing_codebase.rst:258
msgid "Use a bare ``assert`` for testing scalars and truth-testing"
msgstr "对标量和真值测试使用裸露的 ``assert`` "

#: ../../source/development/contributing_codebase.rst:259
msgid ""
"Use ``tm.assert_series_equal(result, expected)`` and "
"``tm.assert_frame_equal(result, expected)`` for comparing :class:`Series`"
" and :class:`DataFrame` results respectively."
msgstr ""
"分别使用 ``tm.assert_series_equal(result, expected)`` 和"
" ``tm.assert_frame_equal(result, expected)`` 对比 :class:`Series` 和"
" :class:`DataFrame` 的输出结果。"

#: ../../source/development/contributing_codebase.rst:260
msgid ""
"Use `@pytest.mark.parameterize <https://docs.pytest.org/en/latest/how-"
"to/parametrize.html>`__ when testing multiple cases."
msgstr ""
"当测试多个用例时，使用 `@pytest.mark.parameterize <https://docs.pytest.org/en/latest/howto/parametrize.html>`__ 。"

#: ../../source/development/contributing_codebase.rst:261
msgid ""
"Use `pytest.mark.xfail "
"<https://docs.pytest.org/en/latest/reference/reference.html?#pytest.mark.xfail>`__"
" when a test case is expected to fail."
msgstr ""
"当预期测试用例会失败时，"
"使用 `pytest.mark.xfail <https://docs.pytest.org/en/latest/reference/reference.html?#pytest.mark.xfail>`__ 。"

#: ../../source/development/contributing_codebase.rst:262
msgid ""
"Use `pytest.mark.skip "
"<https://docs.pytest.org/en/latest/reference/reference.html?#pytest.mark.skip>`__"
" when a test case is never expected to pass."
msgstr ""
"当测试用例预计永远无法通过时，"
"使用 `pytest.mark.skip <https://docs.pytest.org/en/latest/reference/reference.html?#pytest.mark.skip>`__ "

#: ../../source/development/contributing_codebase.rst:263
msgid ""
"Use `pytest.param "
"<https://docs.pytest.org/en/latest/reference/reference.html?#pytest-"
"param>`__ when a test case needs a particular mark."
msgstr ""
"当测试用例需要特定的标记时，"
"使用 `pytest.param <https://docs.pytest.org/en/latest/reference/reference.html?#pytest-param>`__ 。"

#: ../../source/development/contributing_codebase.rst:264
msgid ""
"Use `@pytest.fixture "
"<https://docs.pytest.org/en/latest/reference/reference.html?#pytest-"
"fixture>`__ if multiple tests can share a setup object."
msgstr ""
"如果多个测试可以共享一个设置对象，"
"则使用 `@pytest.fixture <https://docs.pytest.org/en/latest/reference/reference.html?#pytest-fixture>`__ 。"

#: ../../source/development/contributing_codebase.rst:268
msgid ""
"Do not use ``pytest.xfail`` (which is different than "
"``pytest.mark.xfail``) since it immediately stops the test and does not "
"check if the test will fail. If this is the behavior you desire, use "
"``pytest.skip`` instead."
msgstr ""
"不要使用 ``pytest.xfail`` （与 ``pytest.mark.xfail`` 不同），因为它会立即停"
"止测试，并且不会检查测试是否会失败。如果这是你想要的行为，请改用 "
"``pytest.skip`` 。"

#: ../../source/development/contributing_codebase.rst:271
msgid ""
"If a test is known to fail but the manner in which it fails is not meant "
"to be captured, use ``pytest.mark.xfail`` It is common to use this method"
" for a test that exhibits buggy behavior or a non-implemented feature. If"
" the failing test has flaky behavior, use the argument ``strict=False``. "
"This will make it so pytest does not fail if the test happens to pass."
msgstr ""
"如果已知某个测试会失败，但是它失败的方式无意被捕捉，可以使用 "
" ``pytest.mark.xfail`` 。通常,这种方法用于测试显示出错误行为或未实现的特"
"性。如果失败的测试有不稳定的行为，请使用参数 ``strict=False``。这将使 "
"pytest不会在测试恰好通过时失败。"

#: ../../source/development/contributing_codebase.rst:277
msgid ""
"Prefer the decorator ``@pytest.mark.xfail`` and the argument "
"``pytest.param`` over usage within a test so that the test is "
"appropriately marked during the collection phase of pytest. For xfailing "
"a test that involves multiple parameters, a fixture, or a combination of "
"these, it is only possible to xfail during the testing phase. To do so, "
"use the ``request`` fixture:"
msgstr ""
"为了在pytest的收集阶段中适当地标记测试，请喜欢使用装饰器 "
" ``@pytest.mark.xfail`` 和参数 ``pytest.param`` ，而不是在测试中使用它们。对"
"于涉及多个参数， fixture或这些组合的测试，只有在测试阶段才可能失败。为"
"此，请使用 ``request``  fixture："

#: ../../source/development/contributing_codebase.rst:289
msgid ""
"xfail is not to be used for tests involving failure due to invalid user "
"arguments. For these tests, we need to verify the correct exception type "
"and error message is being raised, using ``pytest.raises`` instead."
msgstr ""
"xfail不适用于涉及因无效用户参数而导致失败的测试。对于这些测试，我们需"
"要使用 ``pytest.raises`` 来验证正确的异常类型和错误消息是否被引发。"


#: ../../source/development/contributing_codebase.rst:296
msgid "Testing a warning"
msgstr "测试警告信息"

#: ../../source/development/contributing_codebase.rst:298
msgid ""
"Use ``tm.assert_produces_warning`` as a context manager to check that a "
"block of code raises a warning."
msgstr ""
"使用 ``tm.assert_produces_warning`` 作为上下文管理器，检查代码块是否引"
"发了警告信息。"

#: ../../source/development/contributing_codebase.rst:305
msgid ""
"If a warning should specifically not happen in a block of code, pass "
"``False`` into the context manager."
msgstr ""
"如果代码块中特别不应该出现警告信息，请将 "
"``False`` 传递到上下文管理器。"

#: ../../source/development/contributing_codebase.rst:312
msgid ""
"If you have a test that would emit a warning, but you aren't actually "
"testing the warning itself (say because it's going to be removed in the "
"future, or because we're matching a 3rd-party library's behavior), then "
"use ``pytest.mark.filterwarnings`` to ignore the error."
msgstr ""
"如果你有一个测试会生成警告信息，但实际上你并不测试警告信息本身（比"
"如因为它将来将被移除，或者因为我们正在匹配第三方库的行为），那么使"
"用 ``pytest.mark.filterwarnings`` 忽略该警告信息。"

#: ../../source/development/contributing_codebase.rst:323
msgid ""
"If you need finer-grained control, you can use Python's `warnings module "
"<https://docs.python.org/3/library/warnings.html>`__ to control whether a"
" warning is ignored or raised at different places within a single test."
msgstr ""
"如果你需要更细粒度的控制，可以使用 Python "
"的 `warnings模块 <https://docs.python.org/3/library/warnings.html>`__ "
"在单个测试中的不同位置控制警告信息是否被忽略或触发。"

#: ../../source/development/contributing_codebase.rst:334
msgid "Testing an exception"
msgstr "测试异常"

#: ../../source/development/contributing_codebase.rst:336
msgid ""
"Use `pytest.raises "
"<https://docs.pytest.org/en/latest/reference/reference.html#pytest-"
"raises>`_ as a context manager with the specific exception subclass (i.e."
" never use :py:class:`Exception`) and the exception message in ``match``."
msgstr ""
"使用 `pytest.raises <https://docs.pytest.org/en/latest/reference/reference.html#pytest-raises>`_ 做为一个上下文管理器，并且使用特定的异常子类(切勿使用"
" :py:class:`Exception`)和 ``match`` 中的异常消息。"

#: ../../source/development/contributing_codebase.rst:345
msgid "Testing involving files"
msgstr "测试涉及文件"

#: ../../source/development/contributing_codebase.rst:347
msgid ""
"The ``tm.ensure_clean`` context manager creates a temporary file for "
"testing, with a generated filename (or your filename if provided), that "
"is automatically deleted when the context block is exited."
msgstr ""
" ``tm.ensure_clean`` 上下文管理器创建一个临时文件用于"
"测试，带有自动生成的文件名(如果提供了文件名，则使用提供的文件名)。当"
"离开上下文时，临时文件被自动删除。"

#: ../../source/development/contributing_codebase.rst:357
msgid "Testing involving network connectivity"
msgstr "测试涉及网络连接"

#: ../../source/development/contributing_codebase.rst:359
msgid ""
"It is highly discouraged to add a test that connects to the internet due "
"to flakiness of network connections and lack of ownership of the server "
"that is being connected to. If network connectivity is absolutely "
"required, use the ``tm.network`` decorator."
msgstr ""
"强烈不建议添加连接到互联网的测试，因为网络连接的不稳定性和连"
"接的服务器的所有权问题。如果绝对需要网络连接，请使用 ``tm.network`` 装饰器。"

#: ../../source/development/contributing_codebase.rst:369
msgid ""
"If the test requires data from a specific website, specify "
"``check_before_test=True`` and the site in the decorator."
msgstr ""
"如果测试需要从特定网站获取数据，请在装饰器中指定"
" ``check_before_test=True`` 和网站名称。"

#: ../../source/development/contributing_codebase.rst:381
msgid "Running the test suite"
msgstr "运行测试套件"

#: ../../source/development/contributing_codebase.rst:383
msgid ""
"The tests can then be run directly inside your Git clone (without having "
"to install Xorbits) by typing::"
msgstr ""
"你可以在你的Git clone仓库内直接运行测试（而无需"
"安装Xorbits），只需输入以下命令："

#: ../../source/development/contributing_codebase.rst:390
msgid ""
"If a handful of tests don't pass, it may not be an issue with your "
"Xorbits installation. Some tests (e.g. some SQLAlchemy ones) require "
"additional setup, others might start failing because a non-pinned library"
" released a new version, and others might be flaky if run in parallel. As"
" long as you can import Xorbits from your locally built version, your "
"installation is probably fine and you can start contributing!"
msgstr ""
"如果有少量测试不通过，可能不是你的"
"Xorbits安装的问题。某些测试（例如某些SQLAlchemy测试）需要"
"进行额外设置，其他测试可能会因为非固定库"
"发布了新版本而开始失败，并行运行的测试可能会出现问题。 只"
"要你能够从本地构建的版本导入Xorbits，你的"
"安装可能就没问题了，你可以开始进行贡献！"

#: ../../source/development/contributing_codebase.rst:396
msgid ""
"Often it is worth running only a subset of tests first around your "
"changes before running the entire suite."
msgstr ""
"通常，在运行整个测试套件之前，先运行一部分测试以检查你的"
"更改是否正确是值得的。"

#: ../../source/development/contributing_codebase.rst:399
msgid "The easiest way to do this is with::"
msgstr "最简单的方法如下："

#: ../../source/development/contributing_codebase.rst:403
msgid "Or with one of the following constructs::"
msgstr "或使用以下结构之一："

#: ../../source/development/contributing_codebase.rst:410
msgid ""
"The ``-r`` report flag will display a short summary info (see `pytest "
"documentation <https://docs.pytest.org/en/4.6.x/usage.html#detailed-"
"summary-report>`_) . Here we are displaying the number of:"
msgstr ""
" ``-r`` 报告标志将显示一个简短的摘要信息（请参见 `pytest "
"documentation <https://docs.pytest.org/en/4.6.x/usage.html#detailed-"
"summary-report>`_ ) 。这里我们显示的是以下数量："

#: ../../source/development/contributing_codebase.rst:414
msgid "s: skipped tests"
msgstr "s: 被跳过的测试"

#: ../../source/development/contributing_codebase.rst:415
msgid "x: xfailed tests"
msgstr "x: 失败了的测试"

#: ../../source/development/contributing_codebase.rst:416
msgid "X: xpassed tests"
msgstr "X: 通过了的测试"

#: ../../source/development/contributing_codebase.rst:418
msgid ""
"The summary is optional and can be removed if you don't need the added "
"information. Using the parallelization option can significantly reduce "
"the time it takes to locally run tests before submitting a pull request."
msgstr ""
"摘要是可选的，如果你不需要附加"
"信息，可以删除它。使用并行化选项可以大大减少"
"提交拉取请求之前在本地运行测试所需的时间。"

#: ../../source/development/contributing_codebase.rst:422
msgid ""
"For more, see the `pytest <https://docs.pytest.org/en/latest/>`_ "
"documentation."
msgstr ""
"了解更多信息，请参阅 `pytest <https://docs.pytest.org/en/latest/>`_ "
"的文档。"

#: ../../source/development/contributing_codebase.rst:425
msgid "Documenting your code"
msgstr "文档化你的代码"

#: ../../source/development/contributing_codebase.rst:427
msgid ""
"When mentioning parts of the API, use a Sphinx ``:func:``, ``:meth:``, or"
" ``:class:`` directive as appropriate. Not all public API functions and "
"methods have a documentation page; ideally links would only be added if "
"they resolve. You can usually find similar examples by checking the "
"release notes for one of the previous versions."
msgstr ""
"在提及API的部分时，应相应地使用Sphinx的 ``:func:``, ``:meth:``, 或"
" ``:class:`` 指令。并非所有公共API函数和"
"方法都有文档页；理想情况下，只有解决了的链接才会被添加。"
"你通常可以通过检查以前版本的发行说明来找到类似的示例。"

#: ../../source/development/contributing_codebase.rst:433
msgid ""
"If your code is a bugfix, add your entry to the relevant bugfix section. "
"Avoid adding to the ``Other`` section; only in rare cases should entries "
"go there. Being as concise as possible, the description of the bug should"
" include how the user may encounter it and an indication of the bug "
"itself, e.g. \"produces incorrect results\" or \"incorrectly raises\". It"
" may be necessary to also indicate the new behavior."
msgstr ""
"如果你的代码是bugfix，请将其条目添加到相关的bugfix部分中。"
"避免添加到 ``其他`` 部分；只有在极少数情况下才应该将条目放置"
"在那里。请尽可能简洁地描述错误，包括用户如何遇到它和错误"
"本身的指示，例如“产生不正确的结果”或“不正确地引发”。"
"可能还需要指示新行为。"

#: ../../source/development/contributing_codebase.rst:440
msgid ""
"If your code is an enhancement, it is most likely necessary to add usage "
"examples to the existing documentation.  This can be done following the "
"section regarding :ref:`documentation <contributing_documentation>`. "
"Further, to let users know when this feature was added, the "
"``versionadded`` directive is used. The sphinx syntax for that is:"
msgstr ""
"如果你的代码是增强功能，则很可能需要"
"向现有文档添加使用示例。可以按照"
" :ref:`documentation <contributing_documentation>` 部分进行操作。"
"另外，为了让用户知道何时添加了此功能，可以使用"
" ``versionadded`` 指令。Sphinx的语法如下："

#: ../../source/development/contributing_codebase.rst:450
msgid ""
"This will put the text *New in version 0.1.0* wherever you put the sphinx"
" directive. This should also be put in the docstring when adding a new "
"function or method or a new keyword argument."
msgstr ""
"这将在你放置Sphinx指令的任何位置上放置文本 *New in version 0.1.0* 。"
"添加新函数、方法或新的关键字参数时，此文本还应包含在docstring中。"

